<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Yet Another Verilog Tutorial</title>
  </head>
  <body>
    <h1 align="center">Yet Another Verilog Tutorial<br>
    </h1>
    <h3>Introduction</h3>
    While studying Boolean algebra, for example when simplifying Boolean
    expressions, you may want to check your answer. One way to do this
    is to generate the truth table for the original expression and your
    simplified expression, and then check that they're the same. There
    are tools online that can help you do that. Another way is through
    computer programming. You could write a short program in your
    favorite programming language with both expressions, and then see
    that they output the same result for all possible combinations of
    the input variables. Yet another way is to use a <a
      href="https://en.wikipedia.org/wiki/Hardware_description_language">hardware









      description language</a> (HDL). An HDL is a specialized computer
    language that you can use to describe digital logic circuits, which
    in turn are described by Boolean expressions. In this tutorial, we
    will be using the <a href="http://www.verilog.com/">Verilog</a>
    HDL. (This tutorial is heavily based on Jose Vargas's Getting
    started with Icarus Verilog on Windows, which is cited in the
    References section below. Some basic programming knowledge is
    recommended before proceeding.)<br>
    <h3>Icarus Verilog<br>
    </h3>
    A program written in an HDL like Verilog is a <i>description</i> of
    a hardware system. HDL programs will be referred to as descriptions
    from this point forward. Unlike programs in typical programming
    languages, after the program is compiled, HDL descriptions are <i>simulated</i>
    instead of executed. Simulation executes a <i>simulation model</i>,
    which is generated by the compiler from the description. We will
    need an HDL simulator to compile and simulate HDL descriptions.
    There are many HDL simulators available. If you're running Windows,
    one free and open-source simulator that is available is <a
      href="http://iverilog.icarus.com/">Icarus Verilog</a> (it runs on
    Macs and Linux as well). <br>
    <h3>Writing a simple program<br>
    </h3>
    Once you have downloaded and installed Icarus Verilog, you are ready
    to write your first Verilog description. We will be writing a
    hardware description of a basic 2-input AND gate. The output of an
    AND gate is 1 if and only if all of its inputs are also 1. Here is
    its truth table:<br>
    <br>
    <table>
      <tbody>
        <tr align="center">
          <td colspan="2"><b>INPUT</b></td>
          <td><b>OUTPUT</b></td>
        </tr>
        <tr align="center">
          <td>A</td>
          <td>B</td>
          <td>A AND B</td>
        </tr>
        <tr align="center">
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr align="center">
          <td>0</td>
          <td>1</td>
          <td>0</td>
        </tr>
        <tr align="center">
          <td>1</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr align="center">
          <td>1</td>
          <td>1</td>
          <td>1</td>
        </tr>
      </tbody>
    </table>
    <br>
    Our first description is <a href="basic_and.v">basic_and.v</a>.
    Here is its code:<br>
    <pre>    module basic_and (a, b, out);
      input a, b;
      output out;
   
      assign out = a &amp; b;
    endmodule

    module basic_and_tb();
      reg a, b;
      wire out;
   
      basic_and DUT (
        .a(a),
        .b(b),
        .out(out)
      );
   
      initial begin
        // Dump results of the simulation to basic_and.vcd
        $dumpfile("basic_and.vcd");
        $dumpvars;

        a = 0;
        b = 0;
        #20
        a = 0;
        b = 1;
        #20
        a = 1;
        b = 0;
        #20
        a = 1;
        b = 1;
        #20
        $finish;
      end
    endmodule
    </pre>
    If you look at the above description, notice that it is composed of
    two modules, each of which starts with the keyword <tt>module</tt>
    and ends with the keyword <tt>endmodule</tt>. The fundamental
    descriptive unit in Verilog is the module, and a Verilog description
    is separated into different modules. You could think of them as
    rough equivalents of functions in other programming languages. The
    first module above, called <tt>basic_and</tt>, is a description of
    our basic AND gate. The second module, called <tt>basic_and_tb</tt>,
    is what is known as a <i>test bench</i>, which is HDL code that
    allows you to provide a documented, repeatable set of stimuli that
    is portable across different simulators. To simulate our design, we
    will need both the Device Under Test (DUT), which in this case is
    our AND gate described in <tt>basic_and</tt>, and the stimulus
    provided by the test bench.<br>
    <br>
    The lines that start with <tt>module</tt> are declarations. The
    declaration states the module's name, and inside the parentheses are
    its inputs and outputs. You can see that inside the module, we
    declare which variables are inputs and outputs using the keywords <tt>input</tt>
    and <tt>output</tt>, respectively. The <tt>assign</tt> keyword
    assigns <tt>out</tt> to be inputs <tt>a</tt> and <tt>b</tt> ANDed
    together using the operator <tt>&amp;</tt>. (Notice that commas (<tt>,</tt>)
    are used to separate elements of a list, and semicolons (<tt>;</tt>)
    are used to terminate Verilog statements. If you know any C-like
    languages, this should be very familiar.)<br>
    <br>
    Let's look at <tt>basic_and_tb</tt> next. First, notice that the
    module declaration does not have any input or output ports. The rest
    of the module can be divided into three parts: (1) declaration, (2)
    instantiation, and (3) simulation:<br>
    <ol>
      <li>Declaration: The inputs to the circuit are declared with
        keyword <tt>reg</tt> and the outputs are declared with the
        keyword <tt> wire</tt>. (For more information on the
        differences between <tt>wire</tt> and <tt>reg</tt>, take a
        look at <a
          href="https://inst.eecs.berkeley.edu/%7Ecs150/Documents/Nets.pdf">Verilog:




          <tt>wire</tt> vs. <tt>reg</tt></a>.)</li>
      <li>Instantation: In the line that starts with <tt>basic_and DUT</tt>,
        we instantiate our <tt>basic_and</tt> module. This is the same
        instantiation that happens in object-oriented programming. When
        we instantiate a module, Verilog creates a unique object from
        the module, and the objects are called instances. <tt>DUT</tt>
        is the name given to this instance. You don't have to name the
        instance <tt>DUT</tt> -- you can give it a different name, if
        you like, but every instantiation of a module needs a unique
        instance name. Furthermore, this instantiation is an example of
        <i>module port mapping by name</i>. For each module input and
        output, we need to indicate which reg or wire in our test bench
        is connected to it. A name following a '.' corresponds to a name
        given in the module declaration, while a name inside parentheses
        corresponds to the name of a reg or wire in our test bench. In
        this example, they happen to be the same. If you have ever
        tested actual hardware before, instantiation is like attaching
        signal generators to the inputs of a circuit and probes to the
        outputs of the circuit.</li>
      <li>Simulation: Here we specify exactly what happens during our
        simulation. This section starts with the keyword <tt>initial</tt>
        and is followed by a set of statements, enclosed by the keywords
        <tt>begin</tt> and <tt>end</tt>, that begin executing when the
        simulation is initialized. The <tt>$dumpfile</tt> and <tt>$dumpvars</tt>
        are commands that tell the Verilog simulator to log the module's
        variables to the file specified. Next, we assign values (0
        initially) to the inputs of the DUT, <tt>a</tt> and <tt>b</tt>.
        Lines that start with '<tt>#</tt>' specify a delay in the
        simulation given in seconds (s). So after 20 s, input <tt>b</tt>
        changes to 1. Note that regs retain their values after they are
        assigned, so the <tt>a=0;</tt> immediately after <tt>#20</tt>
        could have been omitted. Continuing in this fashion, we are
        specifying the input waveforms to be every possible combination
        of inputs <tt>a</tt> and <tt>b</tt> for a period of 20 s.
        Finally, the <tt>$finish</tt> system task explicitly tells the
        simulator to stop the simulation.<br>
      </li>
    </ol>
    <h3>Compiling and simulating<br>
    </h3>
    The following instructions are specific to Windows, but the
    procedure is not that different on Macs and Linux:<br>
    <ul>
      <li>To compile, open a Command Prompt and <tt>cd</tt> to the
        directory where the file <tt>basic_and.v</tt> is saved. <br>
      </li>
      <li>Type:</li>
    </ul>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <tt>iverilog -o basic_and
      basic_and.v</tt><br>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iverilog</tt> is the name of the
    Icarus Verilog compiler. The "<tt>-o</tt>" specifies the name of the
    output file. If no output file name is specified, iverilog uses the
    default name <tt>a.out</tt>. (If you know C/C++, this is the same
    thing that happens if you don't specify "<tt>-o</tt>" to <tt>gcc</tt>
    or <tt>g++</tt>.)<br>
    <ul>
      <li>Our source file is now compiled, but the file <tt>basic_and</tt>
        is not executable. We need to run the simulation next by typing:</li>
    </ul>
    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <tt>vvp basic_and</tt><br>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vvp</tt> stands for Verilog
    Virtual Processor. It is the run time engine that executes the
    default compiled form generated by Icarus Verilog. It's what outputs
    the <tt>basic_and.vcd</tt> file with all the simulation results.
    (In case you are wondering what VCD is, it's an industry standard
    simulation dump format.)<br>
    <br>
    Next, we will need a tool to visualize the simulation results.
    GTKWave is such a tool that comes with the Windows version of Icarus
    Verilog.<br>
    <ul>
      <li>To open it, press the Windows key and type "gtkwave" (without
        the quotes). The GTKWave GUI should appear. <br>
      </li>
      <li>Then click File -&gt; Open New Tab.</li>
      <li>Choose the basic_and.vcd file.</li>
    </ul>
    We've opened the file, but we don't see any waveforms yet. If we
    want to see a timing diagram, we need to specify which variables we
    want to see the timing diagrams for.<br>
    <ul>
      <li>In the top left, you should see a panel labeled "SST" with our
        module <tt>basic_and_tb</tt>. Click on <tt>basic_and_tb</tt>.</li>
      <li>All the variables we declared in that module should appear in
        the panel below SST. Select all the variables using Ctrl or
        Shift, and then drag them over to the "Signals" panel just to
        the right.</li>
    </ul>
    If all goes well, you should get a timing diagram just like the
    following:<br>
    <br>
    <img src="basic_and.png" alt="GTKWave Waveform" width="1002"
      height="632"><br>
    <br>
    Compare this timing diagram with the truth table given earlier.
    Notice that waveform of <tt>out</tt>, the output of the AND gate,
    is always low (or 0) until time = 60 s to time = 80 s, when it's
    high (or 1). That's the only time that both inputs <tt>a</tt> and <tt>b</tt>
    are 1. So our waveform bears out what the truth table says the
    output of an AND gate should be.<br>
    <br>
    This was just a very simple example designed to serve as a brief
    introduction to Verilog. This is just the tip of the iceberg of what
    Verilog can do. If you want to learn more, take a look at the
    references below, and start creating Verilog descriptions of your
    own!<br>
    <h3>References</h3>
    <ul>
      <li>
        <div class="bibliography-item-copy-text content col-md-12"
          data-clipboard-target="copy-target-641420636"
          data-redirect-target="/items/641420636/copy"
          data-style-code="apa"
          href="http://www.citationmachine.net/bibliographies/283060962?new=true#"
          id="copy-target-641420636">Mano, M. M., &amp; Ciletti, M. D.
          (2013). <i>Digital design: with an introduction to the
            verilog HDL</i> (5th ed.). Upper Saddle River, NJ: Pearson.</div>
      </li>
      <li>
        <div id="c-p-offscreen-div">
          <div class="content">
            <div class="bibliography-item-copy-text content col-md-12"
              data-clipboard-target="copy-target-640045290"
              data-redirect-target="/items/640045290/copy"
              data-style-code="apa"
              href="http://www.citationmachine.net/bibliographies/283060962?new=true#"
              id="copy-target-640045290">Mano, M. M., Kime, C. R., &amp;
              Martin, T. (2015). <i>Logic and computer design
                fundamentals</i> (5th ed.). Boston: Pearson.</div>
          </div>
        </div>
      </li>
      <li>
        <div class="bibliography-item-copy-text content col-md-12"
          data-clipboard-target="copy-target-640143184"
          data-redirect-target="/items/640143184/copy"
          data-style-code="apa"
          href="http://www.citationmachine.net/bibliographies/283060962?new=true#"
          id="copy-target-640143184">Tala, D. K. (2014, February 09).
          Verilog In One Day Part-I. Retrieved February 19, 2018, from <a
href="http://www.asic-world.com/verilog/verilog_one_day1.html">
            http://www.asic-world.com/verilog/verilog_one_day1.html</a></div>
      </li>
      <li>
        <div class="bibliography-item-copy-text content col-md-12"
          data-clipboard-target="copy-target-640225096"
          data-redirect-target="/items/640225096/copy"
          data-style-code="apa"
          href="http://www.citationmachine.net/bibliographies/283060962?new=true#"
          id="copy-target-640225096">Test Benches. (2008). Retrieved
          February 19, 2018, from <a
href="https://www.xilinx.com/itp/xilinx10/isehelp/ise_c_simulation_test_bench.htm">https://www.xilinx.com/itp/xilinx10/isehelp/ise_c_simulation_test_bench.htm</a></div>
      </li>
      <li>
        <div class="bibliography-item-copy-text content col-md-12"
          data-clipboard-target="copy-target-640047970"
          data-redirect-target="/items/640047970/copy"
          data-style-code="apa"
          href="http://www.citationmachine.net/bibliographies/283060962?new=true#"
          id="copy-target-640047970">Vargas, J. (2013, October 10).
          Getting started with Icarus Verilog on Windows. Retrieved
          February 19, 2018, from <a
            href="https://codeitdown.com/icarus-verilog-on-windows/">https://codeitdown.com/icarus-verilog-on-windows/</a></div>
      </li>
      <li>
        <div class="bibliography-item-copy-text content col-md-12"
          data-clipboard-target="copy-target-641461996"
          data-redirect-target="/items/641461996/copy"
          data-style-code="apa"
          href="http://www.citationmachine.net/bibliographies/283060962?new=true#"
          id="copy-target-641461996">VLSIFacts. (n.d.). Retrieved
          February 20, 2018, from <a href="http://www.vlsifacts.com/">http://www.vlsifacts.com/</a></div>
      </li>
    </ul>
    <a href="index.html">Back to homepage.</a>
  </body>
</html>
